// CustomTreeCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "CustomTreeCtrl.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CCustomTreeCtrl

CCustomTreeCtrl::CCustomTreeCtrl()
{
	m_bNoPaint = FALSE;
}


CCustomTreeCtrl::~CCustomTreeCtrl()
{
}



BEGIN_MESSAGE_MAP(CCustomTreeCtrl, CToolTipsTreeCtrl)
	//{{AFX_MSG_MAP(CCustomTreeCtrl)
	ON_WM_PAINT()
	ON_NOTIFY_REFLECT_EX(TVN_SELCHANGED, OnSelChanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////
// CCustomTreeCtrl Overidables

BOOL CCustomTreeCtrl::DrawItem(CTreeCursor &hTreeItem,CDC &cdc,
								CRect &crect,UINT nState,DWORD &dwWidth)
{
	COLORREF rgbHighlight, rgbHighlightText ;
	CRect	crectTemp, crectSize ;
	CString text;
	UINT sFlag = TVIS_DROPHILITED | TVIS_SELECTED;

	
	text = hTreeItem.GetText();
	if(nState & sFlag)
	{
		rgbHighlight = GetSysColor(COLOR_HIGHLIGHT);
		rgbHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);

		crectTemp.top = crectTemp.left = 0;
		cdc.DrawText(text, &crectTemp,DT_SINGLELINE | DT_CALCRECT);
		
		crect.right = crect.left + 4 + crectTemp.right;
		cdc.FillSolidRect(&crect,rgbHighlight);
		rgbHighlightText = cdc.SetTextColor(rgbHighlightText);
		rgbHighlight = cdc.SetBkColor(rgbHighlight);
		
		crect.left += 2;
		cdc.DrawText(text,&crect,DT_VCENTER | DT_SINGLELINE);		
		crect.left -= 2;

		if(GetFocus() == this && m_hSelItem == hTreeItem)
		{
			cdc.DrawFocusRect(&crect);
		}

		cdc.SetTextColor(rgbHighlightText);
		cdc.SetBkColor(rgbHighlight);
	}
	else
	{
		cdc.FillSolidRect(&crect,GetSysColor(COLOR_WINDOW));
		crect.left += 2;
		cdc.DrawText(text, &crect,DT_VCENTER | DT_SINGLELINE);
		crect.left -= 2;
	}

	crectSize.SetRectEmpty();
	cdc.DrawText(text,&crectSize,
					DT_VCENTER | DT_SINGLELINE | DT_CALCRECT);

	dwWidth = crectSize.Width();
	return FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// CCustomTreeCtrl message handlers


void CCustomTreeCtrl::OnPaint() 
{	
	CTreeCursor	hTreeItem;
	CRect		crect, crectClient, crectInvalid, crectTemp;
	UINT		nState;
	BOOL		bFocus;
	CFont		*pcfont;
	CFont		*pcfontOld;
	DWORD		dwWidth;

	// If we are flagged to ignore this pain message, 
	// then validate rect and return
	if(m_bNoPaint)
	{
		m_bNoPaint = FALSE;		
		ValidateRect(NULL);
		return ;
	}	

	// Retrieve Invalid Rect for use throughout paint handler
	GetUpdateRect(&crectInvalid);	
	
	// If we have focus, store this fact, but then turn it off
	bFocus = (GetFocus() == this);
	if(bFocus)
	{
		// Make sure any paint message generated by 
		// SetFocus() does nothing
		m_bNoPaint = TRUE;
		::SetFocus(NULL);

		// Make sure that or Invalid rect is the same as it 
		// was upon entering the paint handler
		ValidateRect(NULL) ;
		InvalidateRect(&crectInvalid);

		// Set Paint Flag so that future paint handling will occur
		m_bNoPaint = FALSE;
	}
	
	// Get that default drawing done... without a focus rect or 
	// selected area	
	CToolTipsTreeCtrl::OnPaint();

	// If we did have focus we will restore it now
	if( bFocus )
	{		
		m_bNoPaint = TRUE;
		SetFocus();
		m_bNoPaint = FALSE;
	}

	// We want a valid window rect now... SetFocus() may have 
	// invalidated some portion of the client
	ValidateRect(NULL);

	// This is the DC that we will use to do our drawing
	CClientDC	cdc(this);	


	GetClientRect(&crectClient);	
		
	// As control we need to make sure we do our drawing in 
	// our font
	pcfont = GetFont();
	pcfontOld = cdc.SelectObject(pcfont);	

	// Now we will enumerate the visible items in the control
	hTreeItem = GetFirstVisibleItem();
	while( hTreeItem )
	{
		// Where is this item in the client
		hTreeItem.GetRect(&crect,TRUE);
		
		// Get the state of the current item to pass to the 
		// DrawItem() Function
		nState = hTreeItem.GetState((UINT)-1);

		// Expand / limit the area of the item to the right 
		// edge of the client
		crect.right = crectClient.right;

		// If the item falls inside of our original 
		// invalid rect then redraw it
		// by calling the overidable virtual function DrawItem()
		if(crectTemp.IntersectRect(&crect,&crectInvalid))
		{
			if(DrawItem(hTreeItem,cdc,crect,nState,dwWidth))
			{
				SetItemWidth(hTreeItem,cdc,dwWidth);
			}
		}

		// Continue through visible items
		hTreeItem = hTreeItem.GetNextVisible();
	}
	// We do this, because SetItemWidth actually changes
	// the text of the items in the control and it 
	// may have flagged a repaint which we don't want to happen
	ValidateRect(NULL) ;

	// Restore previous font in DC
	cdc.SelectObject(pcfontOld);
}


void CCustomTreeCtrl::SetItemWidth(CTreeCursor &hTreeItem,CDC &cdc, 
									DWORD dwWidth)
{
	int			nSpaceWidth, nSpaces;
	CString		cstr ;

	cdc.GetCharWidth(' ',' ', &nSpaceWidth);
	
	// I don't know when a space wouldn't have width, but I would 
	// hate to see a divide by zero error.
	if( !nSpaceWidth )
		return ;

	nSpaces = dwWidth / nSpaceWidth + ((dwWidth % nSpaceWidth)?1:0);

	cstr = hTreeItem.GetText();
	if(cstr.GetLength() != nSpaces)
	{
		hTreeItem.SetText(CString(' ',nSpaces));
	}
}

BOOL CCustomTreeCtrl::OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
	m_hSelItem = CTreeCursor(pNMTreeView->itemNew.hItem,this);
	
	*pResult = 0;
	return FALSE;
}

